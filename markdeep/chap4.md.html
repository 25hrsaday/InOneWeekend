<meta charset="utf-8">

Chapter 4: Adding a sphere
Let’s add a single object to our ray tracer. People often use spheres in ray tracers because
calculating whether a ray hits a sphere is pretty straightforward. Recall that the equation for a
sphere centered at the origin of radius R is x*x + y*y + z*z = R*R. The way you can read that
equation is “for any (x, y, z), if  x*x + y*y + z*z = R*R then (x,y,z) is on the sphere and
otherwise it is not”. It gets uglier if the sphere center is at (cx, cy, cz):

    (x-cx)*(x-cx) + (y-cy)*(y-cy) + (z-cz)*(z-cz)= R*R

In graphics, you almost always want your formulas to be in terms of vectors so all the x/y/z stuff
is under the hood in the vec3 class. You might note that the vector from center C = (cx,cy,cz) to
point p = (x,y,z) is ( p - C ) . And dot(( p - C ),( p - C )) = (x-cx)*(x-cx) + (y-cy)*(y-cy) +
(z-cz)*(z-cz) . So the equation of the sphere in vector form is:

    dot(( p - c ),( p - c )) = R*R

We can read this as “any point p that satisfies this equation is on the sphere”. We want to know if
our ray p (t) = A + t* B ever hits the sphere anywhere. If it does hit the sphere, there is some t
for which p (t) satisfies the sphere equation. So we are looking for any t where this is true:

    dot(( p (t) - c ),( p (t) - c )) = R*R

or expanding the full form of the ray p(t):

    dot(( A + t* B - C ),( A + t* B - C )) = R*R

The rules of vector algebra are all that we would want here, and if we expand that equation and
move all the terms to the left hand side we get:

    t*t*dot( B , B ) + 2*t*dot( B,A - C ) + dot( A-C,A - C ) - R*R = 0

The vectors and R in that equation are all constant and known. The unknown is t, and the equation is
a quadratic, like you probably saw in your high school math class. You can solve for t and there is
a square root part that is either positive (meaning two real solutions), negative (meaning no real
solutions), or zero (meaning one real solution). In graphics, the algebra almost always relates very
directly to the geometry. What we have is:

{image}

If we take that math and hard-code it into our program, we can test it by coloring red any pixel
that hits a small sphere we place at -1 on the z-axis:

{code}

What we get is this:

{image}

Now this lacks all sorts of things-- like shading and reflection rays and more than one object--
but we are closer to halfway done than we are to our start! One thing to be aware of is that we
tested whether the ray hits the sphere at all, but t < 0 solutions work fine. If you change your
sphere center to z = +1 you will get exactly the same picture because you see the things behind
you. This is not a feature! We’ll fix those issues next.


<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
